{"remainingRequest":"/home/caro/Documents/vodrecord-krowdy/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/caro/Documents/vodrecord-krowdy/src/components/WebCam.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/caro/Documents/vodrecord-krowdy/src/components/WebCam.vue","mtime":1566345316988},{"path":"/home/caro/Documents/vodrecord-krowdy/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/caro/Documents/vodrecord-krowdy/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/caro/Documents/vodrecord-krowdy/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/caro/Documents/vodrecord-krowdy/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\nlet mediaRecorder;\n// exporto componente para usarlo en otros componentes\nexport default {\n  name: 'WebCam',\n  \n  props: {\n    title: String,\n\n  },\n\n  data: () => {\n    return {\n      nombre: 'nombre',\n      \n    }\n  },\n  methods: {\n    // Comenzar a grabar\n    // async: await solo funciona cuando el metodo es asincrono\n    // async signficia que tu metodo va a tener una f.asincrona(no se sabe cuando va a terminar)\n    async startRecord() {\n      console.log('Se empezo a grabar!!');\n      try {\n        // stream: Flujo de datos\n        // await va a esperar que acepte o rechace los permisos\n        // stream obtiene un objeto MediaStream\n        const stream = await navigator.mediaDevices.getUserMedia({ //MediaStream\n          audio: true, \n          video: true \n        });\n        console.log(stream);\n        //comienza el proceso de grabacion\n        this.handleSuccess(stream);\n      } catch (e) {\n        console.log(e);\n      }\n    },\n\n    //Metodo para detener grabacion\n    stopRecord() {\n      console.log('El video se detiene');\n      //el metodo MediaRecorder.stop, detiene la grabación, en cuyo momento dataavailable activa un evento que contiene el final Blob de los datos guardados. No se produce más grabación.\n      mediaRecorder.stop();\n      //MediaStream.getTracks, devuelve una lista de todos los objetos almacenados en MediaStream objeto \n      stream.getTracks()[0].stop();\n      stream.getTracks()[1].stop();\n\n      this.$emit('onstop', 'end');\n    },\n\n    // Grabacion\n    handleSuccess(stream) {\n      // con window hacemos una variable global\n      window.stream = stream;\n      mediaRecorder = new MediaRecorder(stream);\n\n      //El evento loadedmetadata ocurre cuando se han cargado metadatos para el audio / video especificado. Los metadatos para audio / video consisten en: duración, dimensiones (solo video) y pistas de texto.\n\n      player.onloadedmetadata = (ev) => {\n        player.play();\n      };\n      \n      player.srcObject = stream;\n\n      //Comienza a grabar medios\n      mediaRecorder.start();\n      \n      let recordedChunks = [];\n\n      //ondataavailable: Se llama para manejar el evento disponible de datos, que se activa periódicamente cada vez que se han registrado milisegundos de medios (o cuando se ha registrado todo el medio, si no se especificó el tiempo). El evento, de tipo BlobEvent, contiene los medios grabados en su propiedad de datos. Luego puede recopilar y actuar sobre los datos multimedia grabados utilizando este controlador de eventos.\n      mediaRecorder.ondataavailable = (ev) => {\n        console.log('Capturar', ev.data);\n        recordedChunks.push(ev.data);\n      };      \n      \n      mediaRecorder.onstop = (ev) => {\n        //blob donde almaceno el video\n        console.log('on stop1');\n        //MediaRecorder(stream, options)\n        let blob = new Blob(recordedChunks, { 'type' : 'video/webm;' });\n        recordedChunks = [];\n        //El método estático URL.createObjectURL () crea un DOMString que contiene una URL que representa el objeto dado en el parámetro. La vida útil de la URL está vinculada al documento en la ventana en la que se creó. La nueva URL del objeto representa el objeto de archivo u objeto Blob especificado.\n        let videoURL = window.URL.createObjectURL(blob);\n        player.src = videoURL;\n        \n        //Implementacion para enviar al servidor\n        const fd = new FormData();\n        console.log('onstop2');\n        fd.append('video', blob, 'blobby.webm');\n        console.log('Haciendo peticion');\n        fetch('http://localhost:8080/uploads',\n        {\n            method: 'post',\n            body: fd\n        }); \n\n        const a = document.createElement('a');\n        a.style.display = 'none';\n        a.href = videoURL;\n        a.download = 'test.webm';\n        document.body.appendChild(a);\n\n        \n        setTimeout(() => {\n          document.body.removeChild(a);\n          window.URL.revokeObjectURL(videoURL);\n        }, 5000);\n      }\n    }\n  },\n\n  mounted() {\n    const downloadLink = document.getElementById('download');\n  }\n};\n",{"version":3,"sources":["WebCam.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"WebCam.vue","sourceRoot":"src/components","sourcesContent":["<!--template es la estructura de archivos de .vue -->\n<template>\n  <div>\n    <!--prop de preguntas-->\n    <h1>{{title}}</h1> \n\n    <!--playsinline:quitar los controles de reproduccion del video ,muted:silenciar el sonido del video que se esta grabando-->\n    <video id=\"player\" width=\"600\" playsinline muted></video>\n    <!--es un metodo-->\n    <br>\n    <b-button id=\"startRecord\" type=\"is-danger\" @click=\"startRecord\">Grabar</b-button>\n    <b-button id=\"stopRecord\" type=\"stopRecord\" @click=\"stopRecord\">Pausar</b-button>\n  <!--<b-button type=\"is-warning\" @click=\"clickMe\">Reset</b-button>-->  \n  </div>\n</template>\n\n<script>\n\nlet mediaRecorder;\n// exporto componente para usarlo en otros componentes\nexport default {\n  name: 'WebCam',\n  \n  props: {\n    title: String,\n\n  },\n\n  data: () => {\n    return {\n      nombre: 'nombre',\n      \n    }\n  },\n  methods: {\n    // Comenzar a grabar\n    // async: await solo funciona cuando el metodo es asincrono\n    // async signficia que tu metodo va a tener una f.asincrona(no se sabe cuando va a terminar)\n    async startRecord() {\n      console.log('Se empezo a grabar!!');\n      try {\n        // stream: Flujo de datos\n        // await va a esperar que acepte o rechace los permisos\n        // stream obtiene un objeto MediaStream\n        const stream = await navigator.mediaDevices.getUserMedia({ //MediaStream\n          audio: true, \n          video: true \n        });\n        console.log(stream);\n        //comienza el proceso de grabacion\n        this.handleSuccess(stream);\n      } catch (e) {\n        console.log(e);\n      }\n    },\n\n    //Metodo para detener grabacion\n    stopRecord() {\n      console.log('El video se detiene');\n      //el metodo MediaRecorder.stop, detiene la grabación, en cuyo momento dataavailable activa un evento que contiene el final Blob de los datos guardados. No se produce más grabación.\n      mediaRecorder.stop();\n      //MediaStream.getTracks, devuelve una lista de todos los objetos almacenados en MediaStream objeto \n      stream.getTracks()[0].stop();\n      stream.getTracks()[1].stop();\n\n      this.$emit('onstop', 'end');\n    },\n\n    // Grabacion\n    handleSuccess(stream) {\n      // con window hacemos una variable global\n      window.stream = stream;\n      mediaRecorder = new MediaRecorder(stream);\n\n      //El evento loadedmetadata ocurre cuando se han cargado metadatos para el audio / video especificado. Los metadatos para audio / video consisten en: duración, dimensiones (solo video) y pistas de texto.\n\n      player.onloadedmetadata = (ev) => {\n        player.play();\n      };\n      \n      player.srcObject = stream;\n\n      //Comienza a grabar medios\n      mediaRecorder.start();\n      \n      let recordedChunks = [];\n\n      //ondataavailable: Se llama para manejar el evento disponible de datos, que se activa periódicamente cada vez que se han registrado milisegundos de medios (o cuando se ha registrado todo el medio, si no se especificó el tiempo). El evento, de tipo BlobEvent, contiene los medios grabados en su propiedad de datos. Luego puede recopilar y actuar sobre los datos multimedia grabados utilizando este controlador de eventos.\n      mediaRecorder.ondataavailable = (ev) => {\n        console.log('Capturar', ev.data);\n        recordedChunks.push(ev.data);\n      };      \n      \n      mediaRecorder.onstop = (ev) => {\n        //blob donde almaceno el video\n        console.log('on stop1');\n        //MediaRecorder(stream, options)\n        let blob = new Blob(recordedChunks, { 'type' : 'video/webm;' });\n        recordedChunks = [];\n        //El método estático URL.createObjectURL () crea un DOMString que contiene una URL que representa el objeto dado en el parámetro. La vida útil de la URL está vinculada al documento en la ventana en la que se creó. La nueva URL del objeto representa el objeto de archivo u objeto Blob especificado.\n        let videoURL = window.URL.createObjectURL(blob);\n        player.src = videoURL;\n        \n        //Implementacion para enviar al servidor\n        const fd = new FormData();\n        console.log('onstop2');\n        fd.append('video', blob, 'blobby.webm');\n        console.log('Haciendo peticion');\n        fetch('http://localhost:8080/uploads',\n        {\n            method: 'post',\n            body: fd\n        }); \n\n        const a = document.createElement('a');\n        a.style.display = 'none';\n        a.href = videoURL;\n        a.download = 'test.webm';\n        document.body.appendChild(a);\n\n        \n        setTimeout(() => {\n          document.body.removeChild(a);\n          window.URL.revokeObjectURL(videoURL);\n        }, 5000);\n      }\n    }\n  },\n\n  mounted() {\n    const downloadLink = document.getElementById('download');\n  }\n};\n</script>\n\n"]}]}