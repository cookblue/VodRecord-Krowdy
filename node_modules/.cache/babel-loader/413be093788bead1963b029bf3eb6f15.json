{"remainingRequest":"/home/caro/Documents/VOD-K/node_modules/babel-loader/lib/index.js!/home/caro/Documents/VOD-K/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/caro/Documents/VOD-K/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/caro/Documents/VOD-K/src/controler/control.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/caro/Documents/VOD-K/src/controler/control.vue","mtime":1566346755530},{"path":"/home/caro/Documents/VOD-K/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/caro/Documents/VOD-K/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/caro/Documents/VOD-K/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/caro/Documents/VOD-K/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/caro/Documents/VOD-K/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nvar mediaRecorder; // exporto componente para usarlo en otros componentes\n\nexport default {\n  name: 'WebCam',\n  props: {\n    title: String\n  },\n  data: function data() {\n    return {\n      nombre: 'nombre'\n    };\n  },\n  methods: {\n    // Comenzar a grabar\n    // async: await solo funciona cuando el metodo es asincrono\n    // async signficia que tu metodo va a tener una f.asincrona(no se sabe cuando va a terminar)\n    startRecord: function () {\n      var _startRecord = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var _stream;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                console.log('Se empezo a grabar!!');\n                _context.prev = 1;\n                _context.next = 4;\n                return navigator.mediaDevices.getUserMedia({\n                  //MediaStream\n                  audio: true,\n                  video: true\n                });\n\n              case 4:\n                _stream = _context.sent;\n                console.log(_stream); //comienza el proceso de grabacion\n\n                this.handleSuccess(_stream);\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](1);\n                console.log(_context.t0);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 9]]);\n      }));\n\n      function startRecord() {\n        return _startRecord.apply(this, arguments);\n      }\n\n      return startRecord;\n    }(),\n    //Metodo para detener grabacion\n    stopRecord: function stopRecord() {\n      console.log('El video se detiene'); //el metodo MediaRecorder.stop, detiene la grabación, en cuyo momento dataavailable activa un evento que contiene el final Blob de los datos guardados. No se produce más grabación.\n\n      mediaRecorder.stop(); //MediaStream.getTracks, devuelve una lista de todos los objetos almacenados en MediaStream objeto \n\n      stream.getTracks()[0].stop();\n      stream.getTracks()[1].stop();\n      this.$emit('onstop', 'end');\n    },\n    // Grabacion\n    handleSuccess: function handleSuccess(stream) {\n      // con window hacemos una variable global\n      window.stream = stream;\n      mediaRecorder = new MediaRecorder(stream); //El evento loadedmetadata ocurre cuando se han cargado metadatos para el audio / video especificado. Los metadatos para audio / video consisten en: duración, dimensiones (solo video) y pistas de texto.\n\n      player.onloadedmetadata = function (ev) {\n        player.play();\n      };\n\n      player.srcObject = stream; //Comienza a grabar medios\n\n      mediaRecorder.start();\n      var recordedChunks = []; //ondataavailable: Se llama para manejar el evento disponible de datos, que se activa periódicamente cada vez que se han registrado milisegundos de medios (o cuando se ha registrado todo el medio, si no se especificó el tiempo). El evento, de tipo BlobEvent, contiene los medios grabados en su propiedad de datos. Luego puede recopilar y actuar sobre los datos multimedia grabados utilizando este controlador de eventos.\n\n      mediaRecorder.ondataavailable = function (ev) {\n        console.log('Capturar', ev.data);\n        recordedChunks.push(ev.data);\n      };\n\n      mediaRecorder.onstop = function (ev) {\n        //blob donde almaceno el video\n        console.log('on stop1'); //MediaRecorder(stream, options)\n\n        var blob = new Blob(recordedChunks, {\n          'type': 'video/webm;'\n        });\n        recordedChunks = []; //El método estático URL.createObjectURL () crea un DOMString que contiene una URL que representa el objeto dado en el parámetro. La vida útil de la URL está vinculada al documento en la ventana en la que se creó. La nueva URL del objeto representa el objeto de archivo u objeto Blob especificado.\n\n        var videoURL = window.URL.createObjectURL(blob);\n        player.src = videoURL; //Implementacion para enviar al servidor\n\n        var fd = new FormData();\n        console.log('onstop2');\n        fd.append('video', blob, 'blobby.webm');\n        console.log('Haciendo peticion');\n        fetch('http://localhost:8080/uploads', {\n          method: 'post',\n          body: fd\n        });\n        var a = document.createElement('a');\n        a.style.display = 'none';\n        a.href = videoURL;\n        a.download = 'test.webm';\n        document.body.appendChild(a);\n        setTimeout(function () {\n          document.body.removeChild(a);\n          window.URL.revokeObjectURL(videoURL);\n        }, 5000);\n      };\n    }\n  },\n  mounted: function mounted() {\n    var downloadLink = document.getElementById('download');\n  }\n};",{"version":3,"sources":["control.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\n\nlet mediaRecorder;\n// exporto componente para usarlo en otros componentes\nexport default {\n  name: 'WebCam',\n  \n  props: {\n    title: String,\n\n  },\n\n  data: () => {\n    return {\n      nombre: 'nombre',\n      \n    }\n  },\n  methods: {\n    // Comenzar a grabar\n    // async: await solo funciona cuando el metodo es asincrono\n    // async signficia que tu metodo va a tener una f.asincrona(no se sabe cuando va a terminar)\n    async startRecord() {\n      console.log('Se empezo a grabar!!');\n      try {\n        // stream: Flujo de datos\n        // await va a esperar que acepte o rechace los permisos\n        // stream obtiene un objeto MediaStream\n        const stream = await navigator.mediaDevices.getUserMedia({ //MediaStream\n          audio: true, \n          video: true \n        });\n        console.log(stream);\n        //comienza el proceso de grabacion\n        this.handleSuccess(stream);\n      } catch (e) {\n        console.log(e);\n      }\n    },\n\n    //Metodo para detener grabacion\n    stopRecord() {\n      console.log('El video se detiene');\n      //el metodo MediaRecorder.stop, detiene la grabación, en cuyo momento dataavailable activa un evento que contiene el final Blob de los datos guardados. No se produce más grabación.\n      mediaRecorder.stop();\n      //MediaStream.getTracks, devuelve una lista de todos los objetos almacenados en MediaStream objeto \n      stream.getTracks()[0].stop();\n      stream.getTracks()[1].stop();\n\n      this.$emit('onstop', 'end');\n    },\n\n    // Grabacion\n    handleSuccess(stream) {\n      // con window hacemos una variable global\n      window.stream = stream;\n      mediaRecorder = new MediaRecorder(stream);\n\n      //El evento loadedmetadata ocurre cuando se han cargado metadatos para el audio / video especificado. Los metadatos para audio / video consisten en: duración, dimensiones (solo video) y pistas de texto.\n\n      player.onloadedmetadata = (ev) => {\n        player.play();\n      };\n      \n      player.srcObject = stream;\n\n      //Comienza a grabar medios\n      mediaRecorder.start();\n      \n      let recordedChunks = [];\n\n      //ondataavailable: Se llama para manejar el evento disponible de datos, que se activa periódicamente cada vez que se han registrado milisegundos de medios (o cuando se ha registrado todo el medio, si no se especificó el tiempo). El evento, de tipo BlobEvent, contiene los medios grabados en su propiedad de datos. Luego puede recopilar y actuar sobre los datos multimedia grabados utilizando este controlador de eventos.\n      mediaRecorder.ondataavailable = (ev) => {\n        console.log('Capturar', ev.data);\n        recordedChunks.push(ev.data);\n      };      \n      \n      mediaRecorder.onstop = (ev) => {\n        //blob donde almaceno el video\n        console.log('on stop1');\n        //MediaRecorder(stream, options)\n        let blob = new Blob(recordedChunks, { 'type' : 'video/webm;' });\n        recordedChunks = [];\n        //El método estático URL.createObjectURL () crea un DOMString que contiene una URL que representa el objeto dado en el parámetro. La vida útil de la URL está vinculada al documento en la ventana en la que se creó. La nueva URL del objeto representa el objeto de archivo u objeto Blob especificado.\n        let videoURL = window.URL.createObjectURL(blob);\n        player.src = videoURL;\n        \n        //Implementacion para enviar al servidor\n        const fd = new FormData();\n        console.log('onstop2');\n        fd.append('video', blob, 'blobby.webm');\n        console.log('Haciendo peticion');\n        fetch('http://localhost:8080/uploads',\n        {\n            method: 'post',\n            body: fd\n        }); \n\n        const a = document.createElement('a');\n        a.style.display = 'none';\n        a.href = videoURL;\n        a.download = 'test.webm';\n        document.body.appendChild(a);\n\n        \n        setTimeout(() => {\n          document.body.removeChild(a);\n          window.URL.revokeObjectURL(videoURL);\n        }, 5000);\n      }\n    }\n  },\n\n  mounted() {\n    const downloadLink = document.getElementById('download');\n  }\n};\n</script>\n\n"],"sourceRoot":"src/controler"}]}